# SEED Labs Stack Overflow Exploit - Shellcode Injection

## Table of Contents
1. [Overview](#overview)
2. [Vulnerability Analysis](#vulnerability-analysis)
3. [Key Challenges Solved](#key-challenges-solved)
   - [GDB vs Runtime Address Difference](#1-gdb-vs-runtime-address-difference)
   - [EDX Register Pollution](#2-edx-register-pollution)
   - [Exploit Reliability](#3-exploit-reliability)
4. [Exploit Strategy](#exploit-strategy)
5. [How to Run](#how-to-run)
6. [Technical Details](#technical-details)
7. [Learning Outcomes](#learning-outcomes)
8. [Mitigation Techniques](#mitigation-techniques)
9. [References](#references)

---

## Overview
This exploit demonstrates a classic stack buffer overflow attack

## Vulnerability Analysis

**Program:** `stack.c`
- **Buffer size:** 24 bytes
- **Vulnerable function:** `strcpy(buffer, str)` - no bounds checking
- **Input:** Reads 517 bytes from `badfile`
- **Exploit space:** 517 - 24 = 493 bytes of overflow!

## Key Challenges Solved

### 1. GDB vs Runtime Address Difference
**Problem:** Addresses in GDB (`0xffffca88`) differ from runtime (`0xffffcb08`)
- **Cause:** GDB adds environment variables that shift the stack by ~224 bytes
- **Solution:** Used `stack_debug.c` to find the true runtime buffer address

### 2. EDX Register Pollution
**Problem:** Standard shellcode failed with segfault even when landing correctly
- **Cause:** The `execve()` system call requires EDX=0, but it contained garbage
- **Solution:** Added `xor edx, edx` instruction to clean the register before syscall

### 3. Exploit Reliability
**Problem:** Exact address calculation is fragile
- **Solution:** NOP spray - fill entire 517-byte buffer with NOPs for a huge landing zone

## Exploit Strategy

### Memory Layout
```
[NOP sled - 483 bytes][Shellcode - 34 bytes]
                      ^
                      |
                 Return address points here (offset ~200)
```

### Payload Structure
1. **Bytes 0-35:** NOP sled (`\x90`)
2. **Bytes 36-39:** Return address (overwrites saved EIP) â†’ points to buffer + 200
3. **Bytes 40-482:** More NOP sled
4. **Bytes 483-516:** Shellcode with EDX clearing

### The Critical Fix: EDX Clearing
```assembly
xor edx, edx    ; \x31\xd2 - Clear EDX register
```
This instruction was the breakthrough that made the exploit work!

## How to Run

### Prerequisites
```bash
# Disable ASLR
sudo sysctl -w kernel.randomize_va_space=0

# Verify stack is executable
readelf -l stack | grep GNU_STACK  # Should show RWE
```

### Execute Exploit
```bash
# Generate the payload
python3 seedlabs_final_fix.py

# Run the vulnerable program
cd ../vulnerable-programs/seedlabs-stack
./stack
```

### Expected Output
```
# (You get a shell)
whoami
root
```

## Technical Details

**Shellcode (34 bytes):**
- Clears EAX, EDX registers
- Pushes `/bin//sh` string to stack
- Sets up argv array
- Calls `execve("/bin/sh", argv, NULL)`

**Offset Calculation:**
- Buffer at: `0xffffcb08`
- Return address at: `buffer + 36` = `0xffffcb2c`
- Jump target: `buffer + 200` = `0xffffcbd0` (middle of NOP sled)

## Learning Outcomes

1. **Stack Layout:** Understanding how local variables, saved registers, and return addresses are arranged
2. **Shellcode:** Writing position-independent assembly that spawns a shell
3. **NOP Sleds:** Using slides for exploit reliability
4. **Register State:** Why syscalls fail with dirty registers
5. **Environment Differences:** GDB vs normal execution address shifts

## Mitigation Techniques

This exploit works because security features are disabled:
- **ASLR:** Disabled (`randomize_va_space=0`)
- **Stack Canaries:** Disabled (`-fno-stack-protector`)
- **NX bit:** Disabled (`-z execstack`)
- **PIE:** Disabled (`-no-pie`)

In production systems, enable all of these!

## References
- SEED Labs: https://seedsecuritylabs.org
- Buffer Overflow Attack Lab (Revised)
- Created by: Berker Koyuncu
- Date: November 22, 2025
